\chapter{Anwendungen}

1. Any-Angle ?
2. Multi-client ?

\section{Anwendung von A* in Videospielen}

Der A* Algorithmus wird in vielen Videospielen für die Bewegungskontrolle von Nicht-Spieler Charakteren (engl. non-player character, NPC) genutzt. Der Umgebung des Spiels liegen in vielen Fällen festen Knoten oder ein Kachelsystem zugrunde. Basiert die Bewegungssteuerung auf dem System der Umgebung, werden die Bewegungen der NPCs jedoch häufig vorhersehbar [1].

In Abbildung 1 ist ein Spiel zu sehen, in dem der Computer den kürzesten Pfad in einem kachelbasierten Spielfinden finden soll. Die Algorithmen A*, Dijkstra und BFS werden in ihren Eigenschaften verglichen. Dijkstra und BFS durchsuchen beide das gesamte Spielfeld, während A* knapp die Hälfte der Kacheln untersucht. Dennoch schafft es Dijkstras Algorithmus schneller einen idealen Pfad zu berechnen als A* [2].

In komplexeren Levels (siehe Abbildung 2 und 3) schafft es A* jedoch schneller als Dijkstra und BFS einen idealen Pfad zu berechnen. Grundsätzlich eignet sich der A* Algorithmus also besser für die Bestimmung des kürzesten Pfads in Videospielen als Dijkstras Algorithmus oder die Breitensuche. [2]

[1][Pathfinding in partially explored games environments]
[2][Comparative Analysis of Pathfinding Algorithms A *, Dijkstra, and BFS on Maze Runner Game]

[Abb 1][Maze Runner]
[Abb 2][Maze Runner2]
[Abb 3][Maze Runner3]




\section{Übersicht der Pfadplanungsansätze oder Verwandte Arbeiten} %todo besser als Verwandte Arbeite und dann geht das in die Richtung Games und Robotics aber andere Darstellung

Das Weltmodell kann für verschiedene Einsatzbereiche unterschiedlich dargestellt werden. Eine Abbildung der realen Welt muss deren Merkmale möglichst präzis erfassen können. Die folgenden Ansätze für die Raumdarstellung führen jeweils Fragestellungen auf Suchprobleme in Graphen zurück. %todo besser umformulieren in Hinblick auf die folgende Auflistung, hier sind mehr eigentlich spielen&roboter Ansätze

\subsection{Geometrische Karten oder Wegkartenverfahren}
%todo Hinblick auf Spiele hier schaffen, um den Raum oder Fläche als Weltmodell darzustellen, 

\textbf{Das Voronoi Diagram}\newline
Bei Erstellung des Voronoi-Diagramms wird der Raum in Regionen (Voronoi-Regionen) zerlegt. Jede Region enhält ihr Zentrum und die Punkte, die zu diesem Zentrum euklidisch näher liegen, als zu jedem anderen Zentrum \cite{voronoi}. \\

\textbf{Sichtbarkeitsgraph} \newline
Ein Sichtbarkeitsgraph enthält alle gegenseitig sichtbaren Orte. Eine Kante zwischen zwei Knotenpunkten existiert genau dann, wenn die Knoten sich gegenseitig sehen. Dies ist der Fall, wenn es keine Hindernisse zwischen den Knoten gibt\cite{visG1}. \\ 

\textbf{Potentialfeldverfahren} \newline
Das Potentialfeldverfahren bietet einen Ansatz, bei dem der Suchraum von Gradienten überspannt wird. Aus den Gradienten werden dann mögliche Bewegungsrichtungen ersichtlich ?? \cite{potField}.\\

\textbf{Zellzerlegungsverfahren}\newline
Die Zellzerlegung ist ein bekanntes Hindernisvermeidungsverfahren, das den hindernisfreien Konfigurationsraum in eine endliche Sammlung nicht überlappender(disjunkter) konvexer Polygone, sogenannte Zellen, zerlegt. In diesen kann leicht ein Pfad gefunden werden. Obwohl dieses Verfahren rechenintensiv ist, besteht sein Vorteil gegenüber anderen Ansätzen zur Planung von Roboterpfaden darin, dass die Zellzerlegung unter geeigneten Annahmen vollständig aufgelöst ist. Andere Verfahren verwenden beispielsweise eine Roadmap oder Potentialfeldverfahren\cite{cd}. \\

\subsection{Topologische Graphen}
Diese Gruppe der Verfahren wird in zwei Gruppen unterteilt. Es gibt informierte und uninformierte Suchalgorithmen. Die beiden Gruppen werden im folgenden Kapitel näher besprochen.

\subsection{Multi-Agent Pathfinding}%TODO: überarbeiten

Ein Szenario in dem mehrere Akteure einen Pfad finden müssen, bei dem keine Kollisionen auftreten dürfen, bezeichnet man als Multi-Agent Pathfinding-Problem (MAPF). Es gibt verschiedene MAPF-Algorithmen, darunter Windowed Hierarchical Cooperative A*, Flow Annotated Replanning und Bounded Multi-Agent A*.

\subsection{Windowed Hierarchical Cooperative A*}
Bei dem Cooperative A*-Algorithmus sucht jeder Agent mit dem A*-Algorithmus in einem dreidimensionalen Graphen, um sein Ziel zu erreichen. Das Ergebnis der Suche teilt er mit den anderen Agenten in einer Reservierungstabelle. Auf diese Weise sind die Agenten in der Lage Kollisionen zu vermeiden. Der Hirarchical Cooperative A*-Algorithmus benutzt eine hierarchische Suche. Windowed Hierarchical Cooperative A*(WHCA*) begrenzt die Suchtiefe für jeden Agent zu einem Fenster. Sobald der Teilpfad in dem Fenster gefunden wurde folgt der Agent diesem Pfad und fängt mit der Berechnung des nächsten Teilpfades an. 
\subsection{Flow Annotated Replanning}
Ähnlich WHCA* nimmt Flow Annotation Replanning (FAR) die Pläne anderer Agentin in die Berechnung auf. Statt aber, wenn ein Pfad blockiert ist, einen neuen Pfad zu berechnen, wartet ein Agent im FAR-Algorithmus einfach auf dem aktuellen Knoten darauf, dass sein Pfad wieder frei wird und er ihn für sich reservieren kann. 

\subsection{Bounded Multi-Agent A*}
Bounded Mulit-Agent A* basiert auf Real-time Adaptive A*.
\cite{Sigurdson.2019}