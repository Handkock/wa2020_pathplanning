

\chapter{Anwendung von Pfadplanungsalgorithmen}

Algorithmen zur Pfadplanung finden in verschiedenen Bereichen Anwendung. Reale Pfadplanungsszenarien, wie Navigation und Logistik, sind durch Graphen modellierbar, auf die Suchalgorithmen angewendet werden können \cite{Botea.2011}. In Computerspielen werden Pfadplanungsalgorithmen für die Bewegung computergesteuerter Charaktere genutzt \cite[S.2]{compare}. Dieses Gebiet birgt die zusätzliche Herausforderung die Bewegungen der Charaktere realistisch zu simulieren. Auch hat der Computer direkten Zugriff auf Umgebungsinformationen, sodass Schätzungen präzise  vorgenommen werden können.


\section{Vergleich von BFS, Dijkstra und A*}

Der A* Algorithmus wird in vielen Videospielen für die Bewegungskontrolle von Nicht-Spieler Charakteren (engl. non-player characters, NPCs) genutzt \cite{Stamford.2014}. Der Grund dafür ist die in vielen Fällen schnellere Berechnung des kürzesten Pfads gegenüber uninformierten Algorithmen. In ihrer Arbeit "Pathfinding Algorithm Efficiency Analysis in 2D Grid" vergleichen Zarembo und Kodors die Laufzeit der Algorithmen BFS, Dijkstra und A*. Tabelle \ref{tab:comp} zeigt eine Gegenüberstellung der Rechenzeiten der Algorithmen bei verschiedenen Rastergrößen. Die Breitensuche benötigt schon bei sehr kleiner Flächengröße deutlich länger als Dijkstra und A*. Je größe die Fläche wird, desto größer wird auch der Unterschied zwischen Dijkstra und A*. Bei einer Rastergröße von 1024x1024 Knoten braucht A* weniger als die Hälfte der Zeit von Dijkstras Algorithmus. Die Breitensuche benötigt hier die 10.000fache Zeit von A*. Das sind knapp vier Stunden, im Gegensatz zu gut einer Sekunde.

\newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}}
\begin{table}[h]
\centering
\begin{tabular}[h]{|C{4cm}|C{2cm}|C{2cm}|C{2cm}|} \hline
	Grid size (nodes) & BFS & Dijkstra & A* \\ \hline
	64x64 & 150 & 6 & 4 \\ \hline
	128x128 & 2803 & 25 & 16 \\ \hline
	256x256 & 48313 & 120 & 77 \\ \hline
	512x512 & 821598 & 515 & 265 \\ \hline
	1024x1024 & 13962457 & 2362 & 1148 \\ \hline
\end{tabular}
\caption{Rechenzeit in ms, in Anlehnung an \cite{Zarembo.2013}}
\label{tab:comp}
\end{table}

A* überprüft bei der Suche nach dem kürzesten Pfad in vielen Fällen deutlich weniger Knoten als Dijkstra \cite[S.20f]{compare}. In einer Umgebung mit vielen Hindernissen kommt A* schneller zu einem Ergebnis als Dijkstra. Die Speicher- und Recheneffizienz von A* hängt von der genutzten heuristischen Funktion ab \cite[S.237]{Noo15}. Es ist sinnvoll den A* Algorithmus an die Umgebung anzupassen, in der er genutzt werden soll.

\section{Erweiterung von A*}
Das Problem Pfadfindung in modernen Spielen muss in Echtzeit gelöst werden. Außerdem sind die Speicher und CPU-Ressourcen oft begrenzt. A* hat Worst-case Komplexität wie BFS \cite{You19} und die Pfadfindung mit großen Datensätze kann zu schwerwiegenden Leistungsengpässen führen.


%todo besserer Einleitungssatz
\subsection{Hierarchical Path-Finding A*}
HPA* ist eine Erweiterung von A*, welcher den durch Abstraktion des Suchraums optimiert \cite{Bot04}. Es wird eine bessere Laufzeit erreicht, indem das Spielwelt hierarchisch aufgeteilt wird.

Es wird das Problem der Reise aus eine Spielstadt nach andere betrachtet. Gegeben sei ein detaillierte Karte mit allen Fahrstrecken und deren Längen in den Städten und zwischen den Städte. HPA* arbeitet nicht mit einem geringen Detaillierungsgrad, wie die einzelne interne Stadtpfaden. Das oben beschriebene Problem kann effizienter gelöst werden, indem zuerst den Pfad auf der Stadtebene und erst dann die Zwischenpfade in jeder durchlaufenden Stadt gesucht werden. Die Hierarchie kann auf mehrere Ebene erweitert werden, wodurch diese Lösung für größere Problembereiche skalierbar wird. HPA funktioniert wie folgt:\\

1. In erstem Schritt wird zur Grenze des Bereichs, der den Startort enthält, fahren.

2. In zweitem wird der Pfad von Startbereich zum Zielbereich gesucht. Das Passiert aber auf eine höhere Abstraktionsebene, wo die Suche schneller ist.

3. In letztem Schritt wird der Pfad vervollständigt, indem man den Bereich, der das Zielstandort, enthält.\\
\begin{sloppypar}
HPA* läuft durchschnittlich 10 mal schneller als der standard A*-Algorithmus \cite{Bot04} und wird daher breit in dem Spieleinbereich angewendet \cite{LSC08}\cite{Kri10}. HPA* ist aber sehr allgemein. ``In der Praxis kann HPA sowohl für statische Welten, wo die Graphenhierarchie besser vorbereitet werden kann, als auch in typischen dynamischen Welten, um häufige Umgebungsänderungen zu bewältigen, erheblich optimiert werden`` \cite{Kri10}. Aus diesem Grund existieren unterschiedliche  HPA*-Erweiterungen wie: SHPA und DHPA vorgeschlagen von Kring et al.\cite{Kri10} oder Path Smoothing und Lazy Edge Weight Computation, die in allgemeinen die Leistung erhöhen \cite{JB07}.
\end{sloppypar}



\section{Multi-Agent Pathfinding}
Bisher wurden Lösungen für die Problemstellung mit einem einzelnen Agenten betrachtet. Ein Szenario in dem mehrere Akteure einen Pfad finden müssen, bei dem keine Kollisionen auftreten dürfen, bezeichnet man als Multi-Agent Pathfinding-Problem (MAPF). Es gibt verschiedene MAPF-Algorithmen, die versuchen mit dieser Problemstellung umzugehen. Darunter gibt es Windowed Hierarchical Cooperative A*, Flow Annotated Replanning und Bounded Multi-Agent A*.

\subsection{Windowed Hierarchical Cooperative A*}
Bei dem Cooperative A*-Algorithmus sucht jeder Agent mit dem A*-Algorithmus in einem dreidimensionalen Graphen, um sein Ziel zu erreichen. Das Ergebnis der Suche teilt er mit den anderen Agenten in einer Reservierungstabelle. Auf diese Weise sind die Agenten in der Lage Kollisionen zu vermeiden. Der Hierarchical Cooperative A*-Algorithmus benutzt eine hierarchische Suche (siehe Oben: 4.2.1 Hierarchical Path-Finding A*). Windowed Hierarchical Cooperative A*(WHCA*) begrenzt die Suchtiefe für jeden Agent zu einem Fenster. Sobald der Teilpfad in dem Fenster gefunden wurde folgt der Agent diesem Pfad und fängt mit der Berechnung des nächsten Teilpfades an.
\subsection{Flow Annotated Replanning}
Ähnlich WHCA* nimmt Flow Annotation Replanning (FAR) die Pläne anderer Agenten in die Berechnung auf. Statt aber, wenn ein Pfad blockiert ist, einen neuen Pfad zu berechnen, wartet ein Agent im FAR-Algorithmus einfach auf dem aktuellen Knoten darauf, dass sein Pfad wieder frei wird und er ihn für sich reservieren kann.

\subsection{Bounded Multi-Agent A*}
Bounded Mulit-Agent A* basiert auf Real-time Adaptive A*(RTAA*). RTAA* wird für ein Multiagenten-Setting erweitert. Andere Agenten werden während der Suche als sich bewegende Hindernisse betrachtet. Außerdem haben Agenten die Möglichkeit andere Agenten dazu aufzufordern Zellen frei zu machen. Der aufgeforderte Agent wird zu einer freien benachbarten Zelle wandern und seine reguläre Such von dort aus fortführen\cite{Sigurdson.2019}.

\section{Verwandte Arbeiten}

\begin{sloppypar}
Pfadplanungsproblem wird oft ebenfalls in Robotik Kontext untersucht. In \cite{LP80} wird der Konfigurationsraum beschrieben. Die Idee besteht darin, dass ein Roboter als ein Punkt betractet wird in diesem Raum betrachtet wird. Nach Latombe\cite{latombe}, %todo check
es existieren folgende Ansätze für Pfadpalnung in einem Konfigurationsraum: Wegkartenverfahren, Zellunterteilungsverfahren und Potentialfelderverfahren.


Bei \textbf{Wegkartenverfahren} wird der Konfigurationsraum in Kurven unterteilt. Einige Versionen davon sind z.B Voronoi-Diagramm \cite{voronoi} %todo check
und der Sichtbarkeitsgraph \cite{LPAW79}. Das \textbf{Potentialfeldverfahren} bietet einen Ansatz, bei dem der Suchraum von Gradienten überspannt wird. Aus den Gradienten werden dann mögliche Bewegungsrichtungen ersichtlich. Die \textbf{Zellzerlegung} \cite{Cai09} kann als Hindernisvermeidungsverfahren bezeichnet werden, das den Konfigurationsraum in eine endliche Sammlung nicht überlappender(disjunkter) konvexer Polygone, sogenannte Zellen, zerlegt.
\end{sloppypar}
