

\chapter{Anwendung von Pfadplanungsalgorithmen}

Algorithmen zur Pfadplanung finden in verschiedenen Bereichen Anwendung. Reale Pfadplanungsszenarien, zum Beispiel im Zusammenhang mit Navigation und Logistik, sind durch Graphen modellierbar, auf die Suchalgorithmen angewendet werden können \cite{Botea.2011}. In Computerspielen werden Pfadplanungsalgorithmen für die Bewegung computergesteuerter Charaktere genutzt \cite[S.2]{Kri09}. Dieses Gebiet birgt die zusätzliche Herausforderung die Bewegungen der Charaktere realistisch zu simulieren. Auch hat der Computer direkten Zugriff auf Umgebungsinformationen, sodass Schätzungen präzise  vorgenommen werden können.


\section{Vergleich von BFS, Dijkstra und A*}

Der A* Algorithmus wird in vielen Videospielen für die Bewegungskontrolle von Nicht-Spieler-Charakteren (engl. non-player characters, NPCs) genutzt \cite{Stamford.2014}. Der Grund dafür ist die in vielen Fällen schnellere Berechnung des kürzesten Pfades gegenüber uninformierten Algorithmen. In ihrer Arbeit ``Pathfinding Algorithm Efficiency Analysis in 2D Grid`` vergleichen Zarembo und Kodors die Laufzeit der Algorithmen BFS, Dijkstra und A*. Tabelle \ref{tab:comp} zeigt eine Gegenüberstellung der Rechenzeiten der Algorithmen bei verschiedenen Rastergrößen. Die Breitensuche benötigt schon bei sehr kleiner Flächengröße deutlich länger als Dijkstra und A*. Je größe die Fläche wird, desto größer wird auch der Unterschied zwischen Dijkstra und A*. Bei einer Rastergröße von 1024x1024 Knoten braucht A* weniger als die Hälfte der Zeit von Dijkstras Algorithmus. Die Breitensuche benötigt hier die 10.000fache Zeit von A*. Das sind knapp vier Stunden, im Gegensatz zu gut einer Sekunde.

\newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}}
\begin{table}[h]
\centering
\begin{tabular}[h]{|C{4cm}|C{2cm}|C{2cm}|C{2cm}|} \hline
	Grid size (nodes) & BFS & Dijkstra & A* \\ \hline
	64x64 & 150 & 6 & 4 \\ \hline
	128x128 & 2803 & 25 & 16 \\ \hline
	256x256 & 48313 & 120 & 77 \\ \hline
	512x512 & 821598 & 515 & 265 \\ \hline
	1024x1024 & 13962457 & 2362 & 1148 \\ \hline
\end{tabular}
\caption{Rechenzeit in ms, in Anlehnung an \cite{Zarembo.2013}}
\label{tab:comp}
\end{table}

A* überprüft bei der Suche nach dem kürzesten Pfad in vielen Fällen deutlich weniger Knoten als Dijkstra \cite[S.20f]{Kri09}. In einer Umgebung mit vielen Hindernissen kommt A* schneller zu einem Ergebnis als Dijkstra. Die Speicher- und Recheneffizienz von A* hängt von der genutzten heuristischen Funktion ab \cite[S.237]{Noo15}. Es ist sinnvoll den A* Algorithmus an die Umgebung anzupassen, in der er genutzt werden soll.

\section{Erweiterung von A*}
Pfadplanungsprobleme müssen in modernen Spielen in Echtzeit gelöst werden. Außerdem sind Speicherplatz und Rechenleistung begrenzt. A* hat die gleiche Worst Case-Komplexität wie BFS \cite{You19}. Daher kann die Pfadplanung mit großen Datensätzen zu schwerwiegenden Leistungsengpässen führen.


%todo besserer Einleitungssatz
\subsection{Hierarchical Path-Finding A*}
\label{sec:hpa}
Hierarchical Path-Finding A* (HPA*) ist eine Erweiterung von A*, welche diesen durch die Abstraktion des Suchraums optimiert \cite{Bot04}. Es wird eine bessere Laufzeit erreicht, indem die Spielwelt hierarchisch aufgeteilt wird.

Es wird das Problem einer Reise aus einer Spielstadt in eine andere betrachtet. Gegeben sei ein detaillierte Karte mit allen Fahrstrecken in und zwischen den Städten, sowie deren Längen. Der A*-Algorithmus kann den optimalen Pfad berechnen, dies kann jedoch aufgrund der Kartengröße viele Rechenressourcen verbrauchen. Das Problem kann effizienter gelöst werden, indem zuerst der Pfad auf der Stadtebene gesucht wird und erst dann die Zwischenpfade in jeder Stadt durchlaufen werden. HPA* arbeitet auf eine höhere Abstraktionsstufe und vernachlässigt einzelne interne Stadtpfade. Die Hierarchie kann auf mehrere Ebene erweitert werden, wodurch diese Lösung für größere Problembereiche skalierbar wird. HPA* funktioniert wie folgt:\\

1. Fahre zur Grenze des Bereichs, der den Standort enthält

2. Suche den Pfad vom Start- zum Zielbereich. Dies geschieht auf einer höheren Abstraktionsebene, auf der die Suche schneller ist.

3. Vervollständige den Pfad durch den Bereich, der den Zielstandort enthält.\\

\begin{sloppypar}
HPA* läuft durchschnittlich zehnmal schneller als der oben beschriebener A*-Algorithmus \cite{Bot04} und wird daher verbreitet im Spieleinbereich angewendet \cite{LSC08}. ``HPA* ist aber sehr allgemein. In der Praxis kann HPA sowohl für statische Welten, wo die Graphenhierarchie besser vorbereitet werden kann, als auch in typischen dynamischen Welten, um häufige Umgebungsänderungen zu bewältigen, erheblich optimiert werden`` \cite{Kri10}. Aus diesem Grund existieren unterschiedliche HPA*-Erweiterungen wie SHPA* und DHPA*, vorgeschlagen von Kring et al. \cite{Kri10}, oder Path Smoothing und Lazy Edge Weight Computation, die im Allgemeinen die Leistung von HPA* erhöhen \cite{JB07}.
\end{sloppypar}



\section{Multi-Agent Pathfinding}
Bisher wurden Lösungen für die Problemstellung mit einem einzelnen Agenten betrachtet. Ein Szenario in dem mehrere Akteure Pfade finden müssen, bei denen keine Kollisionen auftreten dürfen, bezeichnet man als Multi-Agent Pathfinding-Problem (MAPF). Es gibt verschiedene MAPF-Algorithmen, die versuchen mit dieser Problemstellung umzugehen. Darunter gibt es Windowed Hierarchical Cooperative A*, Flow Annotated Replanning und Bounded Multi-Agent A*.

\subsection{Windowed Hierarchical Cooperative A*}
Bei dem Cooperative A*-Algorithmus sucht jeder Agent in einem dreidimensionalen Graphen - bestehend aus der x- und der y-Koordinatenachse und einer Zeitachse - mit dem A*-Algorithmus nach seinem Ziel. 
Das Ergebnis der Suche teilt er den anderen Agenten in einer Reservierungstabelle mit. Auf diese Weise sind die Agenten in der Lage Kollisionen zu vermeiden. 
Der Hierarchical Cooperative A*-Algorithmus benutzt eine hierarchische Suche (siehe Oben: \hyperref[sec:hpa]{4.2.1 Hierarchical Path-Finding A*}). Windowed Hierarchical Cooperative A*(WHCA*) begrenzt die Suchtiefe für jeden Agent zu einem Fenster. Sobald der Teilpfad in dem Fenster gefunden wurde folgt der Agent diesem Pfad und fängt mit der Berechnung des nächsten Teilpfades an.
\subsection{Flow Annotated Replanning}
Ähnlich WHCA* nimmt Flow Annotation Replanning (FAR) die Pläne anderer Agenten in die Berechnung auf. Statt aber, wenn ein Pfad blockiert ist, einen neuen Pfad zu berechnen, wartet ein Agent im FAR-Algorithmus einfach auf dem aktuellen Knoten darauf, dass sein Pfad wieder frei wird und er ihn für sich reservieren kann.

\subsection{Bounded Multi-Agent A*}
Bounded Mulit-Agent A* basiert auf Real-time Adaptive A*(RTAA*). RTAA* wird für ein Multiagenten-Setting erweitert. Andere Agenten werden während der Suche als sich bewegende Hindernisse betrachtet. Außerdem haben Agenten die Möglichkeit andere Agenten dazu aufzufordern Zellen frei zu machen. Der aufgeforderte Agent wird zu einer freien benachbarten Zelle wandern und seine reguläre Suche von dort aus fortführen\cite{Sigurdson.2019}.

\section{Verwandte Arbeiten}

\begin{sloppypar}
	
Der Bellman-Ford-Algorithmus ist ein weiterer Pfadplanungsalgorithmus, der, im Gegensatz zu Dijkstra-Algorithmus, den kürzesten Pfad in einem Graphen mit negativen Kantenkosten finden kann \cite{Bel58}. Er wird beispielsweise in Routing-Protokollen wie Routing Information Protocol (RIP) benutzt \cite{Hed88}.

Das Problem des kürzesten Pfades wird ebenfalls häufig im Kontext der Robotik untersucht. In Automatic Planning of Manipulator Transfer Movements \cite{LP80} wird der Konfigurationsraum beschrieben, in dem ein Roboter als ein Punkt betrachtet wird. Es existieren unterschiedliche Verfahren, die sich mit der Pfadplanung in einem Konfigurationsraum beschäftigen. Diese sind zum Beispiel das Voronoi-Diagramm \cite{Lee82}, der Sichtbarkeitsgraph \cite{LPAW79} und das Zellzerlegungsverfahren \cite{Cai09} .
\end{sloppypar}
