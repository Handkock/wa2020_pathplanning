\chapter{Uniformierte und Informierte Algorithmen}

Die Pfadplanung in Hinblick auf Graphentheorie wird in zwei Gruppen unterteilt: informierte und nicht-informierte Algorithmen. Nicht-informierte Pfadplanung oder Blindsuche wird in alle Richtungen durchgeführt. In der Informierten Pfadplanung wird eine heuristische Funktion verwendet, die die bestimmte Richtung zum Ziel schätzt. Bei dieser Methode wird normalerweise zuerst der Zielort bestimmt\cite{comAnal}.

\section{Nicht-informierte Algorithmen}
Algorithmen dieser Gruppe werden verwendet, wenn es keine Informationen über die Entfernung vom Start zum Ziel bekannt sind. Nicht-informierte Algorithmen garantieren, dass der kürzeste Pfad gefunden wird (falls ein solcher Pfad existiert)\cite{comAnal}. Weil die nicht-informierten Algorithmen gehen über allen möglichen erreichbaren Knoten, es gibt ein großer Bedarf an Speicherplatz und Leistung. Aus diesem Grund sind diese Algorithmen in der Pfadplanung nicht so oft benutzt, wie die informierten\cite{sim} \cite{comAnal}. Die meinst verwendete Algorithmen dieser Gruppe sind: Breitensuche(BFS), Tiefensuche(DFS) und Dijkstra Algorithmus.

\subsection{Breitensuche}

Die Breitensuche (engl. Breadth-First Search, BFS) ist einer der einfachsten Algorithmen für die Suche in einem Graphen. Der Algorithmus hat seinen Namen durch das Prinzip erst nach allen Knoten mit einer Distanz $k$ zu suchen, bevor im nächsten Schritt nach Knoten mit der Distanz $k + 1$ gesucht wird \cite{Cormen.2009}. Die Breitensuche ist dazu in der Lage den kürzesten Pfad zwischen zwei Punkten zu bestimmen. Zusätzlich kann sie einen Pfad bestimmen, der möglichst wenig andere Pfade kreuzt, oder bestmöglich Hindernisse vermeidet \cite{Lee.1961}. BFS dient als Grundmuster für Shortest Path Algorithmen in ungerichteten Graphen \cite{Ottmann.2017}. Die Breitensuche kann jedoch sowohl in gerichteten als auch ungerichteten Graphen genutzt werden. Sie hat eine Laufzeit von $O(V + E)$, also die Summe der Anzahl von Knoten und Kanten \cite{Cormen.2009}.

In einem Graphen $G = (V, E)$ mit einem festgelegten Startknoten $s$ überprüft BFS systematisch alle Kanten im Graphen. Wird ein Knoten $v$ gefunden, wird die Distanz (Anzahl Kanten) vom Startknoten aus berechnet. Anschließend wird der Knoten zu einem speziellen „Breitensuchbaum“ hinzugefügt, welcher alle vom Startknoten aus erreichbaren Knoten beinhaltet. Der Zweig vom Startknoten $s$ zu einem Knoten $v$ im Breitensuchbaum ist repräsentativ für den kürzesten Pfad zwischen $s$ und $v$ \cite{Cormen.2009}.

\subsubsection{BFS Anwendung}
Die Breitensuche kann in mehreren Graph Zusammenhänge verwendet werden.  Mit BFS kann überprüft werden, ob ein Graph Bipartit ist \cite{propTest}. Ausserdem BFS Algorithmus liefert Zusammenhangskomponente eines Graphen\cite{schmitz}. Darüber hinaus BFS und seine Hybride Versionen\cite{effHyb} werden in der GPU Graph Traversierung benutzt\cite{scaleGPU}. 

\subsection{Tiefensuche}

Die Tiefensuche (engl. Depth-First Search, DFS) stellt das Gegenstück zur Breitensuche dar. Sie untersucht die Folgeknoten des zuletzt erreichten Knoten. DFS sucht so lange nach tieferliegenden Knoten, bis das Ende der Kette erreicht wurde. Dann wird ein Rücksetzverfahren angewendet, das sogenannte „Backtracking“ \cite{Tarjan.1972}. Hierbei untersucht der Algorithmus die Kette der Knoten schrittweise rückwärts auf unentdeckte Kanten. Wird ein Knoten mit unentdeckten Kanten gefunden, geht DFS wieder so lange in Tiefe, bis das Ende erreicht ist. Diese abwechselnden Phasen des Untersuchens von Kanten und des Rücksetzens wird so lange angewendet, bis alle Knoten des Graphen gefunden wurden \cite{Cormen.2009}. Die Tiefensuche hat, bei einer Tiefe von $d$, eine generelle Laufzeit von $O(e^d)$. Die Speicherkomplexität beträgt hingegen $O(d)$ \cite{Korf.1985}. Für das Zwischenspeichern der gefundenen Knoten bietet sich ein Stack an, da der Algorithmus selbst nach dem „first in, first out“ Prinzip funktioniert \cite{Tarjan.1972}.  


\subsubsection{DFS Anwendung}
Tiefensuche genauso wie die Breitensuche kann die Zusammenhangskomponenten eines Gprahen finden. \cite{schmitz} \cite{dfs}.  Planarity Testing \cite{dfsPlanar}, Topoligsche Sortierung mit DFS
Es können Irrgärten generiert werden sowie den Weg daraus gefunden werden\cite{examMaze}.


\subsection{Dijkstra Algorithmus}

In seiner Arbeit „Two Problems in Connexion with Graphs“ stellt Dijkstra zwei Probleme dar \cite{Dijkstra.1959}. Das eine ist Konstruktion eines Baums mit den kürzesten Wegen zwischen den Knoten eines Graphen (vergleiche Breitensuchbaum). Das andere Problem ist die Suche nach dem kürzesten Weg zwischen zwei Knoten.
Zur Lösung des Problems des kürzesten Wegs zwischen zwei Knoten $P$ und $Q$ werden Knoten $R$ genutzt, welche auf dem Pfad zwischen $P$ und $Q$ liegen. Da ein Knoten aus $R$ Teil des kürzesten Wegs zwischen $P$ und $Q$ ist, ist auch der Weg zwischen $P$ und $R$ minimal. Es werden wachsend längere Verbindungen zwischen $P$ und $R$ gesucht, bis der Zielknoten $Q$ erreicht wurde.
Zur schrittweisen Annäherung an die Lösung nutzt der Algorithmus drei verschiedene Mengen von Knoten. Menge $A$ sind die Knoten, für die die minimale Distanz vom Startknoten $P$ aus bekannt ist. Menge $B$ sind jene Knoten, die direkt mit einem Knoten aus $A$ verbunden sind, aber nicht Teil von $A$ sind. In $C$ befinden sich alle übrigen Knoten.
Zusätzlich wird eine Baumstruktur genutzt, welcher der Lösung des ersten von Dijkstra aufgeführten Problems entspricht. Der Baum besitzt drei Hauptzweige. In den ersten beiden Zweigen befinden sich die Verbindungen vom Startknoten $P$ zu den Knoten der Mengen $A$ und $B$, respektive. Pro Knoten der Menge $B$ wird jedoch nur eine Verbindung zu $P$ gespeichert. Im dritten Zweig befinden sich alle übrigen Verbindungen. 
Zu Beginn des Lösungsprozesses liegen alle Knoten in $C$. Der Startknoten $P$ wird in $A$ abgelegt. Nun werden wiederholend folgende zwei Schritte ausgeführt:
1.	Es werden alle Verbindungen $r$ zwischen dem zuletzt in $A$ abgelegten Knoten und Knoten $R$ aus $B$ oder $C$ überprüft. Liegt $R$ in $B$, so wird überprüft, ob die Verbindung zu $R$ über $A$ kürzer ist als die im zweiten Zweig befindliche. Sollte dies der Fall sein, ersetzt $r$ den im zweiten Zweig abgelegten Pfad zwischen $P$ und $R$. Liegt $R$ in $C$, so wird der Knoten in $B$ verschoben und $r$ dem zweiten Zweig hinzugefügt.
2.	Werden für die Knoten $B$ lediglich Verbindungen des ersten Zweigs und eine Verbindung des zweiten betrachtet, besitzt jeder Knoten aus $B$ eine feste Länge zu $P$. Der Knoten aus $B$ mit der kürzesten Distanz zu $P$ wird nach $A$ verschoben und seine Verbindung im ersten Zweig des Baums abgelegt.
Diese Schritte werden so lange wiederholt bis Zielknoten $Q$ in $A$ verschoben wurde.
Der Algorithmus hat allgemein eine Komplexität von $O(n^2)$ \cite{Madkour.2017}. Deshalb schlugen Fredman und Tarjan 1984 die Nutzung eines Fibonacci Heaps zur Verbesserung des Dijkstra Algorithmus vor \cite{Fredman.1987}. Unter Anwendung eines solche F-Heaps stellt der Dijkstra Algorithmus den asymptotisch schnellsten bekannten Algorithmus zur Lösung des Shortest Path Problems in gerichteten Graphen dar \cite{Schmitz.2019}.  Die Komplexität beträgt $O(n\ log\ n + m)$ \cite{Madkour.2017}. 



\subsubsection{Dijkstra Anwendung}

Dijkstra und seine Erweiterungen besitzen ein sehr breites Anwendungsspektrum, wie zum Beispiel: Transport Netzwerke in sicheren und unsicheren Umgebungen, \cite{fuzzyDijk} \cite{publicTrans}, in Satellitennetzwerken \cite{satelite} und in Hardware \cite{hardware}. 

\section{Informierte Suchalgorithmen anhand von A*}

Die sogenannte Bestensuche (engl. informed best-first search) ist ein verbreiteter Ansatz für Problemlösungen, um die Suchzeit anhand heuristischer Informationen zu verkürzen. Heuristische Informationen werden durch Schätzverfahren angenähert. Dabei wird versucht jedem Kandidaten einen Wert zuzuweisen. Anhand dieser Wertzuweisung wird die Erkundung in einem Graphen in die Richtung des vielversprechendsten Kandidaten fortgeführt.

\subsection{A*} 

Es sei ein gewichteter Graph G gegeben, der den Startknoten s und eine nichtleere Menge aus Zielknoten T habe. Das Problem des optimalen Pfades besteht nun darin, den Pfad vom Startknoten s zu einem Knoten aus der Zielmenge T mit den geringsten Kosten zu finden. Die Kosten bestehen aus den Gewichten, die den Knoten zugewiesen sind\cite{RinaDechterandJudeaPearl.1983}.

Häufig untersucht wurde in diesem Zusammenhang der Algorithmus A*. Um den kürzesten Pfad mit dem geringsten Aufwand zu finden, profitiert ein Suchalgorithmus von informierten Entscheidungen für die Untersuchung der Knotenpunkte. Untersucht er Knotenpunkte, die offensichtlich nicht zum Ziel führen können, verschwendet er Ressourcen. Untersucht er andererseits Knoten nicht, welche zum kürzesten Pfad beitragen, führt der Algorithmus nicht zum richtigen Ergebnis.

Der Algorithmus A* folgt bestimmten Schritten. 
\begin{itemize}
\item[1.] Der Startknoten s wird als „offen“ markiert und die Funktion f berechnet. Als “offen” werden Knoten bezeichnet, die von dem Algorithmus besucht und für die Untersuchung freigeschaltet werden.
\item[2.] Derjenige offene Knoten n wird ausgewählt, für den die Funktion f den geringsten Wert liefert. Anschließend werden beliebige angrenzende Knoten ausgewählt, aber immer zugunsten jedes Knotens aus der Zielmenge T.
\item[3.] Es wird überprüft ob sich der aktuelle Knoten n in der Zielmenge befindet. Ist das der Fall wird er als „geschlossen“ markiert und der Algorithmus terminiert. Ein Knoten gilt als “geschlossen” sobald die Funktionsberechnung für ihn durchgeführt und ein Ergebnis festgestellt wurde. 
\item[4.] Andernfalls wird der Knoten n als „geschlossen“ markiert und es werden alle Nachfolger von n erkundet. Dann wird f für jeden Nachfolger berechnet und jeder Nachfolger als „offen“ markiert, der nicht als „geschlossen“ markiert wurde. Gibt es nun Nachfolgeknoten die als „geschlossen“ markiert sind, für welche die Funktion f einen geringeren Wert liefert, werden diese Knoten als „offen“ markiert. Daraufhin wird Schritt zwei wieder ausgeführt. Solange, bis der Algorithmus terminiert und der kürzeste Pfad durch den Graphen gefunden wurde\cite{HartNilssonandRaphael.1968}.
\end{itemize}


A* benutzt eine spezielle Form der Funktion f zusammengesetzt aus der Summe f(n) = g(n) + h(n). g(n) spiegelt die additiven Kosten des momentanen Pfades von dem Startknoten s zu dem jetzigen Knoten n wieder. h(n) liefert eine heuristische Einschätzung, welche die Kosten des Restpfades zum Zielknoten schätzt\cite{RinaDechterandJudeaPearl.1983}.

