\chapter{Uniformierte und Informierte Algorithmen}

Einleitung
-	Grundlegende Erklärung der Unterscheidung zwischen uninformierten und informierten Algorithmen (Heuristik) \newline
-	Ggf. eine Vorstellung der verschiedenen Shortest Path Probleme?


\section{ Nicht-informierte Algorithmen}
Nicht-informierte Pfadplanung oder Blindsuche wird in alle Richtungen durchgeführt. Algorithmen dieser Gruppe werden verwendet, wenn es keine Informationen über die Entfernung vom Start zum Ziel bekannt sind. Nicht-informierte Algorithmen garantieren, dass der kürzeste Pfad gefunden wird (falls ein solcher Pfad existiert). \cite{comAnal}. Weil die nicht-informierten Algorithmen gehen über allen möglichen erreichbaren Knoten, es gibt ein großer Bedarf an Speicherplatz und Leistung. Aus diesem Grund sind diese Algorithmen in der Pfadplanung nicht so oft benutzt, wie die informierten\cite{sim} \cite{comAnal}. Die meinst verwendete Algorithmen dieser Gruppe sind: Breitensuche(BFS), Tiefensuche(DFS) und Dijkstra Algorithmus.

\subsection{Breitensuche}

Die Breitensuche (engl. Breadth-First Search, BFS) ist einer der einfachsten Algorithmen für die Suche in einem Graphen. Der Algorithmus hat seinen Namen durch das Prinzip erst nach allen Knoten mit einer Distanz k zu suchen, bevor im nächsten Schritt nach Knoten mit der Distanz k+1 gesucht wird \cite{Cormen.2009}[1]. Die Aufgabe von BFS ist es Pfadverbindungsprobleme zu lösen. Die Breitensuche ist dazu in der Lage den kürzesten Pfad zwischen zwei Punkten zu bestimmen. Zusätzlich kann sie einen Pfad bestimmen, der möglichst wenig andere Pfade kreuzt, oder bestmöglich Hindernisse vermeidet \cite{}[2]. BFS dient als Grundmuster für Shortest Path Algorithmen in ungerichteten Distanzgraphen \cite{}[7]. Die Breitensuche kann jedoch sowohl in gerichteten als auch ungerichteten Graphen genutzt werden. Sie hat eine Laufzeit von O (V + E), also die Summe der Anzahl von Knoten und Kanten \cite{}[1].

In einem Graphen G = (V, E) mit einem festgelegten Startknoten s überprüft BFS systematisch alle Kanten im Graphen. Wird ein Knoten v gefunden, wird die Distanz (Anzahl Kanten) vom Startknoten aus berechnet. Anschließend wird der Knoten zu einem speziellen „Breitensuchbaum“ hinzugefügt, welcher alle vom Startknoten aus erreichbaren Knoten beinhaltet. Der Zweig vom Startknoten s zu einem Knoten v im Breitensuchbaum ist repräsentativ für den kürzesten Pfad zwischen s und v \cite{}[1].

\subsubsection{BFS Anwendung}
Die Breitensuche kann in mehreren Graph Zusammenhänge verwendet werden.  Mit BFS kann überprüft werden, ob ein Graph Bipartit ist \cite{propTest}. Ausserdem BFS Algorithmus liefert Zusammenhangskomponente eines Graphen\cite{schmitz}. Darüber hinaus BFS und seine Hybride Versionen\cite{effHyb} werden in der GPU Graph Traversierung benutzt\cite{scaleGPU}. 

\subsection{Tiefensuche}

Die Tiefensuche (engl. Depth-First Search, DFS) stellt das Gegenstück zur Breitensuche dar. Sie untersucht die Folgeknoten des zuletzt erreichten Knoten. DFS sucht so lange nach tieferliegenden Knoten, bis das Ende der Kette erreicht wurde. Dann wird ein Rücksetzverfahren angewendet, das sogenannte „Backtracking“ \cite{}[10]. Hierbei untersucht der Algorithmus die Kette der Knoten schrittweise rückwärts auf unentdeckte Kanten. Wird ein Knoten mit unentdeckten Kanten gefunden, geht DFS wieder so lange in Tiefe, bis das Ende erreicht ist. Diese abwechselnden Phasen des Untersuchens von Kanten und des Rücksetzens wird so lange angewendet, bis alle Knoten des Graphen gefunden wurden \cite{}[8, 9]. Die Tiefensuche hat, bei einer Tiefe von d, eine generelle Laufzeit von O (e^d). Die Speicherkomplexität beträgt hingegen O (d) \cite{}[8]. Für das Zwischenspeichern der gefundenen Knoten bietet sich ein Stack an, da der Algorithmus selbst nach dem „first in, first out“ Prinzip funktioniert \cite{}[10].  


\subsubsection{DFS Anwendung}
Tiefensuche genauso wie die Breitensuche kann die Zusammenhangskomponenten eines Gprahen finden. \cite{schmitz} \cite{dfs}.  Planarity Testing \cite{dfsPlanar}, Topoligsche Sortierung mit DFS
Es können Irrgärten generiert werden sowie den Weg daraus gefunden werden\cite{examMaze}.


\subsection{Dijkstra Algorithmus}

In seiner Arbeit „Two Problems in Connexion with Graphs“ stellt Dijkstra zwei Probleme dar \cite{}[3]. Das eine ist Konstruktion eines Baums mit den kürzesten Wegen zwischen den Knoten eines Graphen (vergleiche Breitensuchbaum). Das andere Problem ist die Suche nach dem kürzesten Weg zwischen zwei Knoten.
Zur Lösung des Problems des kürzesten Wegs zwischen zwei Knoten P und Q werden Knoten R genutzt, welche auf dem Pfad zwischen P und Q liegen. Da ein Knoten aus R Teil des kürzesten Wegs zwischen P und Q ist, ist auch der Weg zwischen P und R minimal. Es werden wachsend längere Verbindungen zwischen P und R gesucht, bis der Zielknoten Q erreicht wurde.
Zur schrittweisen Annährung an die Lösung nutzt der Algorithmus drei verschiedene Mengen von Knoten. Menge A sind die Knoten, für die die minimale Distanz vom Startknoten P aus bekannt ist. Menge B sind jene Knoten, die direkt mit einem Knoten aus A verbunden sind, aber nicht Teil von A sind. In C befinden sich alle übrigen Knoten.
Zusätzlich wird eine Baumstruktur genutzt, welcher der Lösung des ersten von Dijkstra aufgeführten Problems entspricht. Der Baum besitzt drei Hauptzweige. In den ersten beiden Zweigen befinden sich die Verbindungen vom Startknoten P zu den Knoten der Mengen A und B, respektive. Pro Knoten der Menge B wird jedoch nur eine Verbindung zu P gespeichert. Im dritten Zweig befinden sich alle übrigen Verbindungen. 
Zu Beginn des Lösungsprozesses liegen alle Knoten in C. Der Startknoten P wird in A abgelegt. Nun werden wiederholend folgende zwei Schritte ausgeführt:
1.	Es werden alle Verbindungen r zwischen dem zuletzt in A abgelegten Knoten und Knoten R aus B oder C überprüft. Liegt R in B, so wird überprüft, ob die Verbindung zu R über A kürzer ist als die im zweiten Zweig befindliche. Sollte dies der Fall sein, ersetzt r den im zweiten Zweig abgelegten Pfad zwischen P und R. Liegt R in C, so wird der Knoten in B verschoben und r dem zweiten Zweig hinzugefügt.
2.	Werden für die Knoten B lediglich Verbindungen des ersten Zweigs und eine Verbindung des zweiten betrachtet, besitzt jeder Knoten aus B eine feste Länge zu P. Der Knoten aus B mit der kürzesten Distanz zu P wird nach A verschoben und seine Verbindung im ersten Zweig des Baums abgelegt.
Diese Schritte werden so lange wiederholt bis Zielknoten Q in A verschoben wurde.
Der Algorithmus hat allgemein eine Komplexität von O (n²) \cite{}[4]. Deshalb schlugen Fredman und Tarjan 1984 die Nutzung eines Fibonacci Heaps zur Verbesserung des Dijkstra Algorithmus vor \cite{}[5]. Unter Anwendung eines solche F-Heaps stellt der Dijkstra Algorithmus den asymptotisch schnellsten bekannten Algorithmus zur Lösung des Shortest Path Problems in gerichteten Graphen dar. \cite{}[6] Die Komplexität beträgt O (n log n + m). \cite{}[4]



\subsubsection{Dijkstra Anwendung}

Dijkstra und seine Erweiterungen besitzen ein sehr breites Anwendungsspektrum, wie zum Beispiel: Transport Netzwerke in sicheren und unsicheren Umgebungen, \cite{fuzzyDijk} \cite{publicTrans2}, in Satellitennetzwerken \cite{satelite} und in Hardware \cite{hardware}. 

\section{Informierte Algorithmen}

