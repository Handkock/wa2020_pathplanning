\chapter{Uninformierte und informierte Suchalgorithmen}

Pfadplanung im Hinblick auf Graphentheorie wird in zwei Gruppen unterteilt: informierte und uninformierte Algorithmen. Uninformierte Pfadplanung oder Blindsuche wird in alle Richtungen durchgeführt. In der informierten Pfadplanung wird die Richtung zum Ziel geschätzt und die Suche in diese Richtung durchgeführt\cite{comAnal}. %todo synonym zum durchführen, weil 2 mal benutzt

\section{Uninformierte Suchalgorithmen}
Algorithmen dieser Gruppe werden verwendet, wenn es keine Informationen über die Entfernung vom Start zum Ziel bekannt sind. %todo s und d verwenden
Sie garantieren, dass der kürzeste Pfad gefunden wird, falls ein solcher Pfad existiert\cite{comAnal}. Weil uninformierte Algorithmen über alle möglichen erreichbaren Knoten gehen, gibt es einen großen Bedarf an Speicherplatz und Leistung. Aus diesem Grund finden diese Verfahren seltenere Anwendung als die informierten \cite{sim}\cite{comAnal}. %todo nur eine Quelle lassen
Die am meisten verwendeten Algorithmen dieser Gruppe sind die Breitensuche, die Tiefensuche und der Algorithmus von Dijkstra.

\subsection{Breitensuche}

Die Breitensuche (engl. Breadth-First Search, BFS) ist ein simpler Suchalgorithmus, welcher in Graphen angewendet werden kann \cite{Cormen.2009}. Der Algorithmus kann den kürzesten Pfad zwischen zwei Punkten zu bestimmen. Dazu ist er in der Lage einen Pfad zu finden, der möglichst wenig andere Pfade kreuzt, oder bestmöglich Hindernisse vermeidet \cite{Lee.1961}. BFS dient als Grundmuster für Shortest Path Algorithmen in ungerichteten Graphen \cite{Ottmann.2017}. Die Breitensuche kann jedoch sowohl in gerichteten als auch ungerichteten Graphen genutzt werden. Sie hat eine Laufzeit von $O(V + E)$, also die Summe der Anzahl Knoten und Kanten \cite{Cormen.2009}.

Die Breitensuche durchläuft einen Graphen systematisch und schrittweise in alle Richtungen. Gegeben ist ein Graph $G = (V, E)$, mit einem festgelegten Startknoten $s$, sowie ein Inkrement $k=1$. Nun werden folgende Schritte in einer Schleife ausgeführt:
\begin{itemize}
\item[1.] Finde alle Knoten, welche $k$ Kanten von $s$ entfernt sind.
\item[2.] Rechne $k + 1$.
\end{itemize}
Diese Schritte werden so lange wiederholt, bis alle Knoten im Graphen gefunden wurden, die von $s$ erreicht werden können. Wird ein Knoten von BFS entdeckt, so wird die Distanz zum Startknoten $s$ berechnet. Anschließend wird der Knoten zu einem speziellen „Breitensuchbaum“ hinzugefügt, welcher alle vom Startknoten aus erreichbaren Knoten beinhaltet. Die Zweige des Baums stellen den kürzesten Pfad von $s$ zu den Knoten des Baumes dar \cite{Cormen.2009}.

\subsection{Anwendung der Breitensuche}
Die Breitensuche kann in mehreren Graphen Zusammenhängen verwendet werden.  BFS kann überprüft, ob ein Graph bipartit ist \cite{propTest}. Außerdem liefert der Algorithmus Zusammenhangskomponenten eines Graphen\cite{schmitz}. Die Breitensuche und ihre Hybridversionen\cite{effHyb} werden im Graphikprozessor für Graphentraversierung benutzt\cite{scaleGPU}. %todo anwendung in Pfadplanung fehlt, z.B. Maze Runner Game Paper

\subsection{Tiefensuche}

Die Tiefensuche (engl. Depth-First Search, DFS) stellt das Gegenstück zur Breitensuche dar. Sie untersucht eine Kette von Folgeknoten bis das Ende der Kette erreicht wurde. Grundlegend lässt sich der Algorithmus in zwei Phasen unterteilen, die „Suche nach tieferliegenden Knoten“[1] und das sogenannte „Backtracking“[2] \cite{Tarjan.1972}:
\begin{itemize}
	\item[1] DFS untersucht den zuletzt gefundenen Knoten auf ausgehende Kanten. Existiert eine unentdeckte Kante, folgt DFS der Kante zum nächsten Knoten. Existiert keine weitere Kante, wechselt der Algorithmus in Phase 2.
	\item[2] DFS setzt zum überliegenden Knoten zurück. Dieser wird auf eine unentdeckte Kante untersucht. Existiert eine weitere Kante, wechselt der Algorithmus zurück in Phase 1. Gibt es keine unentdeckte Kante, setzt DFS erneut zurück.
\end{itemize}
Das Verfahren der Tiefensuche endet sobald der Algorithmus zum Startknoten $s$ zurückgesetzt hat und bei $s$ keine unentdeckten Kanten verbleiben. Beim Endecken eines Knoten wird die Distanz zu $s$ berechnet, und der kürzeste Pfad zu $s$ in einen „Tiefensuchbaum“ eingepflegt (vergleiche Breitensuchbaum). Bei der Tiefensuche können jedoch mehrere Bäume entstehen, welche dann einen sogenannten „Tiefensuchwald“ formen \cite{Cormen.2009}. 
Für das Zwischenspeichern der gefundenen Knoten bietet sich ein Stack an, da der Algorithmus selbst nach dem „first in, first out“ Prinzip funktioniert \cite{Tarjan.1972}. Die Tiefensuche hat eine Laufzeit von $\Theta(V + E)$ \cite{Cormen.2009}.


\subsection{Anwendung der Tiefensuche}
Tiefensuche genauso wie die Breitensuche kann die Zusammenhangskomponenten eines Graphen finden. \cite{schmitz} \cite{dfs}. Außerdem kann der Graph auf die Planarität \cite{dfsPlanar} getestet werden und es kann die Topoligsche Sortierung gefunden werden. Es können Irrgärten generiert werden sowie den Weg daraus gefunden werden\cite{examMaze}. %todo noch mehr Pfadplanung anwendungen


\subsection{Der Algorithmus von Dijkstra}
%todo am besten auch schrittweise oder so machen, dass man die Punkte aus dem Kotext unterscheiden kann
In seiner Arbeit „Two Problems in Connexion with Graphs“ stellt Dijkstra zwei Probleme dar \cite{Dijkstra.1959}. Das erste Problem ist die Konstruktion eines Baums mit den kürzesten Wegen zwischen den Knoten eines Graphen (vergleiche Breitensuchbaum). Das andere ist die Suche nach dem kürzesten Weg zwischen zwei Knoten.

Zur Lösung des Problems des kürzesten Wegs zwischen zwei Knoten $P$ und $Q$ 
%todo warum hier P und Q und davor s und d ?
werden Knoten $R$ %todo = {r1, r2, ...}
genutzt, welche auf dem Pfad zwischen $P$ und $Q$ liegen. Da ein Knoten %todo r el R
aus $R$ Teil des kürzesten Wegs zwischen $P$ und $Q$ ist, ist auch der Weg zwischen $P$ und $R$ minimal. Es werden wachsend längere Verbindungen zwischen $P$ und $R$ gesucht, bis der Zielknoten $Q$ erreicht wurde. %todo am besten präziser die r und R beschreiben, wobei r teil von R ist, hier ist wirklich unklar ist: was ist was
Zur schrittweisen Annäherung an die Lösung nutzt der Algorithmus drei %todo warum Annäherung
verschiedene Mengen von Knoten. Menge $A$ sind die Knoten, für die die minimale Distanz vom Startknoten $P$ aus bekannt ist. Menge $B$ sind jene Knoten, die direkt mit einem Knoten aus $A$ verbunden sind, aber nicht Teil von $A$ sind. In $C$ befinden sich alle übrigen Knoten. %todo am besten auch Als Mengen definieren, so ist alles klarer
Zusätzlich wird eine Baumstruktur genutzt, welche der Lösung des ersten von Dijkstra aufgeführten Problems entspricht. %todo vielleicht: einfach löst ?
Der Baum besitzt drei Hauptzweige. In den ersten beiden Zweigen befinden sich die Verbindungen vom Startknoten $P$ zu den Knoten der Mengen $A$ und $B$, respektive die Verbindungen der Knoten der Mengen $A$ und $B$ zum Startknoten $P$ . Pro Knoten der Menge $B$ wird jedoch nur eine Verbindung zu $P$ gespeichert. Im dritten Zweig befinden sich alle übrigen Verbindungen. 
Zu Beginn des Lösungsprozesses liegen alle Knoten in $C$. Der Startknoten $P$ wird in $A$ abgelegt. Nun werden wiederholend folgende zwei Schritte ausgeführt:


1.	Es werden alle Verbindungen $r$ zwischen dem zuletzt in $A$ abgelegten Knoten und Knoten $R$ aus $B$ oder $C$ überprüft. Liegt $R$ in $B$, so wird überprüft, ob die Verbindung zu $R$ über $A$ kürzer ist als die im zweiten Zweig befindliche. Sollte dies der Fall sein, ersetzt $r$ den im zweiten Zweig abgelegten Pfad zwischen $P$ und $R$. Liegt $R$ in $C$, so wird der Knoten in $B$ verschoben und $r$ dem zweiten Zweig hinzugefügt.


2.	Werden für die Knoten $B$ lediglich Verbindungen des ersten Zweigs und eine Verbindung des zweiten betrachtet, besitzt jeder Knoten aus $B$ eine feste Länge zu $P$. Der Knoten aus $B$ mit der kürzesten Distanz zu $P$ wird nach $A$ verschoben und seine Verbindung im ersten Zweig des Baums abgelegt.
Diese Schritte werden so lange wiederholt bis Zielknoten $Q$ in $A$ verschoben wurde.

Der Algorithmus hat eine Komplexität von $O(n^2)$ \cite{Madkour.2017}. Deshalb schlugen Fredman und Tarjan 1984 die Nutzung eines Fibonacci Heaps zur Verbesserung des Dijkstra Algorithmus vor \cite{Fredman.1987}. Unter Anwendung eines solche F-Heaps stellt der Dijkstra Algorithmus den asymptotisch schnellsten bekannten Algorithmus zur Lösung des Shortest Path Problems in gerichteten Graphen dar \cite{Schmitz.2019}.  Die Komplexität beträgt $O(n\ log\ n + m)$ \cite{Madkour.2017}. %todo n und m unterscheiden ?



\subsection{Anwendung des Dijkstra-Algorithmus }

Der Suchalgorithmus von Dijkstra und dessen Erweiterungen besitzen ein sehr breites Anwendungsspektrum, zum Beispiel in Transportnetzwerken in sicheren und unsicheren Umgebungen \cite{fuzzyDijk} \cite{publicTrans} %todo eine Quelle weg
verwendent. Außerdem findet der Algorithmus Verwendung in Satellitennetzwerken \cite{satelite} und in der Entwicklung von Hardware \cite{hardware}.  %todo noch 1-2 Anwendungen, z.B: Maze Runner Paper

\section{Informierte Suchalgorithmen}

Die sogenannte Bestensuche (engl. informed best-first search)  %todo keine Quelle? 
ist ein verbreiteter Ansatz für Problemlösungen %todo für alle oder nur für kurz. Pfad?
, um die Suchzeit %todo von shortest Path ?
anhand heuristischer Informationen zu verkürzen. Diese %todo wer ?
werden durch Schätzverfahren angenähert. Dabei wird versucht jedem Kandidaten %todo was für Kandidat ?
einen Wert zuzuweisen. Anhand dieser Wertzuweisung wird die Erkundung in einem Graphen in die Richtung des vielversprechendsten Kandidaten fortgeführt. 
%todo hier muss auf jedem Fall eine Herleitung zu A* stehen

\subsection{A*} 

Es sei ein gewichteter Graph $G$ gegeben, der den Startknoten $s$ und eine nichtleere Menge aus Zielknoten $T$ habe. Das Problem des optimalen Pfades besteht nun darin, den Pfad vom Startknoten $s$ zu einem Knoten aus der Zielmenge $T$ mit den geringsten Kosten zu finden. %todo Wiederholung des Shortest Path Problems, was eigentlich am Anfang richtig definiert werden muss und hier einfach verlinkt
Die Kosten bestehen aus den Gewichten, die den Knoten zugewiesen sind\cite{RinaDechterandJudeaPearl.1983}.

%todo hier ist die 
Der A* Algorithmus wird häufig in diesem Zusammenhang untersucht. Um den kürzesten Pfad mit dem geringsten Aufwand zu finden, profitiert ein Suchalgorithmus von informierten Entscheidungen für die Untersuchung der Knotenpunkte. Untersucht er Knotenpunkte, die offensichtlich nicht zum Ziel führen können, verschwendet er Ressourcen. Untersucht er andererseits Knoten nicht, welche zum kürzesten Pfad beitragen, führt der Algorithmus nicht zum richtigen Ergebnis. %todo letzte 3 Sätze müssen vielleicht nach oben oder überhaupt zur Beschreibung der infomierten Algos
A* benutzt eine spezielle Form der Funktion $f$ zusammengesetzt aus der Summe $f(n) = g(n) + h(n)$. Die Funktion $g(n)$ spiegelt die additiven Kosten des momentanen Pfades von dem Startknoten $s$ zu dem jetzigen Knoten $n$ wieder. Die Funktion $h(n)$ liefert eine heuristische Einschätzung, welche die Kosten des Restpfades zum Zielknoten schätzt\cite{RinaDechterandJudeaPearl.1983}. %todo wie schon besprochen, die h und g müssen besser aus dem KOntext unterschieden werden können 

%todo ich finde n als einzeln Knoten nicht gut, weil n z.B. für eingabelänge bei Laufzeit bei Fredrik benutzt wird, ist besser hier vlt. x oder u 

Der Algorithmus A* folgt bestimmten Schritten. 
\begin{itemize}
\item[1.] Der Startknoten $s$ wird als „offen“ markiert und die Funktion $f(n)$ berechnet. Als “offen” werden die Knoten bezeichnet, die von dem Algorithmus besucht und für die Untersuchung freigeschaltet worden sind.
\item[2.] Derjenige offene Knoten $n$ wird ausgewählt, für den die Funktion $f(n)$ %todo ist schon besser f(n) hier, weil hier Bezug auf n gibt
den geringsten Wert liefert. Anschließend werden beliebige angrenzende Knoten ausgewählt, aber immer zugunsten jedes Knotens aus der Zielmenge $T$.
\item[3.] Es wird überprüft, ob sich der aktuelle Knoten $n$ in der Zielmenge befindet. Ist das der Fall, wird er als „geschlossen“ markiert und der Algorithmus terminiert. Ein Knoten gilt als “geschlossen” sobald die Berechnung der Funktion $f$ für ihn durchgeführt wurde. %todo finden ich den Satz nicht wirklich sinnvoll
\item[4.] %todo was ist der Erster Fall ?
Andernfalls wird der Knoten $n$ als „geschlossen“ markiert und es werden alle Nachfolger von $n$ erkundet. Dann wird $f(n)$ für jeden Nachfolger berechnet und jeder Nachfolger als „offen“ markiert, der nicht als „geschlossen“ markiert wurde. Gibt es nun Nachfolgeknoten die als „geschlossen“ markiert sind, für welche die Funktion $f$ einen geringeren Wert liefert, werden diese Knoten als „offen“ markiert. Daraufhin wird Schritt zwei wieder ausgeführt. Solange, bis der Algorithmus terminiert und der kürzeste Pfad durch den Graphen gefunden wurde\cite{HartNilssonandRaphael.1968}.
\end{itemize}


